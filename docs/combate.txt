Com base nas fontes, a lógica algorítmica decidida para as ações dos heróis em Heroes of Majesty: The Legacy (agora definido para ser desenvolvido na Godot Engine) é uma Arquitetura de IA Híbrida.
Esta arquitetura não depende de uma única técnica, mas combina três sistemas principais para garantir que os heróis pareçam "vivos", imprevisíveis e autônomos. A lógica opera como um funil de decisão: Estratégia (O Quê) -> Tática (Como) -> Estado (Execução).
Aqui está o detalhamento técnico de como o algoritmo funciona:
1. O Cérebro Estratégico: IA de Utilidade (Utility AI)
Este é o sistema principal que responde à pergunta: "Qual é a melhor coisa para eu fazer agora?".
• Pontuação de Ações: A cada "tick" de decisão (ou intervalo de tempo), o herói avalia uma lista de possíveis ações (ex: Atacar Inimigo, Comprar Poção, Explorar, Descansar, Roubar Loot).
• Considerações (Inputs): Cada ação recebe uma pontuação (0.0 a 1.0) baseada em vários fatores do ambiente e do próprio herói. Exemplos de inputs:
    ◦ Distância do Alvo
    ◦ Vida Atual (HP)
    ◦ Valor da Recompensa (Gold)
    ◦ Nível de Ameaça do Inimigo.
• Curvas de Resposta (A "Personalidade"): A mágica acontece aqui. Os traços de personalidade do herói funcionam como modificadores matemáticos dessas considerações.
    ◦ Herói Corajoso: A curva de Vida Atual mantém a pontuação de "Atacar" alta mesmo quando o HP está em 30%.
    ◦ Herói Covarde: A curva faz a pontuação de "Atacar" cair drasticamente se o HP estiver abaixo de 80%, aumentando a pontuação da ação "Fugir".
    ◦ Herói Ganancioso: Aplica um multiplicador alto na consideração Valor da Recompensa ou Loot no Chão, podendo priorizar pegar ouro em vez de ajudar um aliado.
2. A Execução Tática: Árvores de Comportamento (Behavior Trees - BT)
Uma vez que a IA de Utilidade escolhe a ação vencedora (ex: "Atacar o Ogro"), a Árvore de Comportamento assume para decidir "Como executar essa ação" passo a passo.
• Fluxo Lógico: Funciona como um fluxograma hierárquico.
    ◦ Exemplo para "Atacar":
        1. Verificar se estou no alcance? -> Não -> Executar nó MoverParaAlvo.
        2. Estou no alcance? -> Sim -> Verificar cooldown de habilidade.
        3. Habilidade pronta? -> Sim -> Executar nó UsarSkillForte.
        4. Habilidade em espera? -> Não -> Executar nó AtaqueBásico.
• Adaptação de Classe: A BT de um Mago terá nós de verificação de distância para manter-se longe (kiting), enquanto a BT de um Guerreiro priorizará fechar a distância.
3. O Gerenciador de Estado: Máquinas de Estados Finitos (FSM)
A FSM gerencia o estado "macro" e exclusivo do herói, garantindo que ele não tente fazer duas coisas conflitantes ao mesmo tempo (como dormir e atacar).
• Estados Definidos: Os heróis transitam entre estados como IDLE (Ocioso), COMBAT (Combate), FLEEING (Fugindo), SHOPPING (Comprando) e SOCIALIZING (Na taverna).
• Transições Forçadas: Eventos críticos podem forçar uma mudança de estado imediata, ignorando a IA de Utilidade momentaneamente.
    ◦ Exemplo: Se o herói recebe um dano massivo que ativa o gatilho de "Medo/Pânico", a FSM força a transição para o estado PANICKED ou FLEEING.
4. A Memória Social e Ética
Para suportar a "Dança de Egos", o algoritmo inclui um banco de dados interno para cada herói:
• Matriz de Relacionamento: Um dicionário que mapeia outros heróis para valores de afinidade (friend, neutral, enemy).
• Memórias de Eventos: O herói armazena logs como saved_by: HeroB ou kill_stolen_by: HeroC.
• Lógica de Decisão Social:
    ◦ Ao avaliar a ação "Ajudar Aliado", a IA de Utilidade verifica a matriz. Se o alvo for um enemy (alguém que roubou seu loot antes), a pontuação da ação "Ajudar" é zerada ou reduzida drasticamente, a menos que o herói tenha o traço Ethics: Moral muito alto.
Resumo do Fluxo na Godot Engine:
1. O Jogo Roda (Game Loop): O mundo processa eventos.
2. Input do Jogador: Você coloca uma recompensa de 500 ouro num Goblin.
3. Processamento (Utility AI):
    ◦ Herói A (Ganancioso): Vê o ouro. A curva de ganância dispara a pontuação de "Caçar Goblin" para 0.95. Ele aceita.
    ◦ Herói B (Covarde): Vê o Goblin. A curva de medo de dano reduz a pontuação para 0.2. Ele ignora.
4. Execução (BT + FSM): O Herói A entra no estado SEEKING_TARGET, usa a Árvore de Comportamento para navegar pelo mapa (agora possivelmente hexagonal ou de nós) e engaja o combate.
5. Resultado: Se o Herói A vencer, ele ganha XP e Ouro. Se perder, a FSM muda para DEFEATED e depois CITY_GUARD (Guarda).
Como o sistema de "redenção do guarda" funciona para heróis derrotados?
Quais são as três camadas da arquitetura de IA híbrida proposta?
Como a personalidade de um herói influencia a aceitação de grupos?

me refiro sem o uso de IA
Compreendo perfeitamente. Você se refere à lógica algorítmica determinística (código puro e matemática), distinguindo-a da "IA Generativa" (como LLMs/ChatGPT) que é usada apenas para o Conselheiro e o Storytelling.
Para a movimentação e decisão dos heróis no motor do jogo (Godot), não há "cérebros artificiais" imprevisíveis. O sistema funciona através de Estruturas de Dados, Máquinas de Estados e Cálculos Matemáticos.
Aqui está a explicação técnica da lógica dos heróis como um sistema de algoritmos, sem o uso de IA generativa:
1. O "Motor" de Decisão: Matemática de Utilidade (Utility Scoring)
Em vez de uma "inteligência" abstrata, o jogo utiliza uma fórmula matemática de pontuação. A cada "tick" (intervalo de processamento), o algoritmo calcula uma nota para cada ação possível e escolhe a mais alta.
• A Fórmula: Pontuação = (Fator do Mundo) x (Traço de Personalidade)
• Exemplo Prático (Decidir se Ataca ou Foge):
    ◦ Input do Mundo: O herói tem 30% de Vida.
    ◦ Cálculo para Herói "Corajoso": O algoritmo consulta uma tabela (Curva de Resposta) onde 30% de vida ainda retorna um valor alto (ex: 0.8). Pontuação de Atacar = 0.8.
    ◦ Cálculo para Herói "Covarde": O algoritmo consulta uma tabela diferente onde 30% de vida retorna zero (0.0). Pontuação de Atacar = 0.0.
    ◦ Resultado: O algoritmo simplesmente executa a ação com o maior número. Para o covarde, a ação "Fugir" terá pontuação maior.
2. O Gerenciador de Comportamento: Máquinas de Estados Finitos (FSM)
O herói não "pensa"; ele obedece a um sistema de estados rígidos que funcionam como interruptores lógicos. O herói só pode estar em um estado por vez.
• Lógica de Transição (Hard-coded):
    ◦ Se Estado Atual == COMBATE E Vida < 20% E Traço == COVARDE -> ENTÃO Mudar para Estado: FUGINDO.
    ◦ Se Estado Atual == MORTO -> ENTÃO iniciar Timer(30s). Quando Timer == 0 -> Mudar para Estado: GUARDA_DA_CIDADE.
• Estados Definidos: O código possui uma lista fixa de comportamentos programados: OCIOSO, COMBATENDO, COMPRANDO, PATRULHANDO, DORMINDO. Não há improvisação; o herói apenas alterna entre esses scripts pré-definidos.
3. A Execução de Tarefas: Árvores de Comportamento (Behavior Trees)
Uma vez que o cálculo matemático escolheu "O Quê" fazer (ex: Atacar), a Árvore de Comportamento executa um fluxograma lógico para realizar a tarefa.
• Fluxograma Lógico (Exemplo "Atacar"):
    1. Está no alcance da arma? -> NÃO -> Executar função MoverPara(alvo).
    2. Está no alcance? -> SIM -> Verificar CooldownDaHabilidade == 0.
    3. Cooldown zerado? -> SIM -> Executar animação AtaqueForte.
    4. Cooldown ativo? -> NÃO -> Executar animação AtaqueBásico.
• Isso garante que o herói siga procedimentos táticos lógicos sem precisar "aprender" nada.
4. O Banco de Dados Social (Dicionários Relacionais)
As relações sociais não são sentimentos, mas variáveis numéricas armazenadas em um dicionário (estrutura de dados).
• Estrutura: Cada herói tem uma lista: Relacionamentos = { "Heroi_B": +10, "Heroi_C": -50 }.
• Lógica de "Vingança":
    ◦ Quando o Heroi_A morre, o código varre a lista de amigos.
    ◦ Se Relacionamentos[Heroi_A] > 50 (Amigo) E Traço == LEAL -> O algoritmo insere uma nova tarefa na fila do amigo: Matar(Assassino_do_Heroi_A).
• Lógica de Kill Steal (KS):
    ◦ Se DanoFinal for causado por Heroi_B em um monstro que Heroi_A estava batendo -> O código subtrai pontos na tabela de relacionamento: Relacionamentos["Heroi_B"] -= 30. Se o valor cruzar o limiar de "Inimigo", ativa a flag de combate PvP.
Resumo da Lógica na Godot Engine
Na prática, dentro da Godot Engine (conforme definido na fonte), o funcionamento é puramente lógico:
1. Game Loop: A cada quadro (frame), o jogo processa a lógica.
2. Sensores: O herói "lê" a área ao redor (raio de visão).
3. Avaliação: Aplica as fórmulas matemáticas (Utilidade) baseadas nos atributos (Dicionário de Personalidade).
4. Execução: Roda o script do estado vencedor (FSM/Behavior Tree).
Portanto, "sem o uso de IA" (Generativa), o jogo é uma simulação sistêmica complexa, onde comportamentos emergentes surgem do choque de centenas de regras lógicas simples e cálculos matemáticos, e não de uma "consciência" artificial.